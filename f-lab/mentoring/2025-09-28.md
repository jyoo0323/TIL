# 이번 주 멘토링 질문 리스트

---
### Reverse Proxy 와 Forward Proxy 에 대한 개념
- Forward Proxy (정방향 프록시)
  - 위치: 클라이언트(사용자)와 인터넷 사이에 위치 
  - 동작 방식: 클라이언트가 직접 서버에 접근하지 않고, 프록시 서버를 통해서만 외부 서버에 요청을 보냄. 
  - 주요 목적:
    - 클라이언트 보안/익명성 보장: 실제 사용자의 IP를 숨기고, 프록시 IP로 대신 요청
    - 접근 제어: 특정 웹사이트나 리소스 차단 (회사/학교 네트워크에서 많이 사용)
    - 캐싱: 자주 요청되는 리소스를 캐시해 네트워크 속도 향상
    - 로깅/감시: 사용자들의 인터넷 사용 기록 추적 가능
  - 사용자가 어떤 서버를 요청할 때, “대신 나가서 가져다 줄래?” 하고 쓰는 것.
  - 예시
    - 회사 내부망에서 직원들이 인터넷을 이용할 때, 모든 요청이 프록시를 거쳐 나감.
    - VPN, 웹 프록시 서비스 (HideMyAss, ProxySite 등).
    
- 🔹 Reverse Proxy (역방향 프록시)
  - 위치: 인터넷과 서버(백엔드 시스템) 사이에 위치
  - 동작 방식: 클라이언트는 실제 서버(IP)를 모르고, 프록시 서버(즉 Reverse Proxy)에게 요청. 프록시가 내부 서버로 전달하고 응답을 대신 돌려줌.
  - 주요 목적:
    - 로드 밸런싱: 여러 서버에 트래픽을 분산
    - 보안: 실제 서버 IP를 감춤, 외부 공격으로부터 보호
    - SSL 종료(Offloading): SSL 인증서를 프록시에서 처리하고 내부 서버는 일반 HTTP로 통신
    - 캐싱: 정적 콘텐츠 캐싱으로 서버 부하 줄임
    - 압축/최적화: 응답 속도 개선
  - 외부 사용자가 어떤 서버에 요청할 때, “내가 받아서 내부 서버 중 적당한 곳에 전달해줄게” 하는 것.
  - 예시
  - Nginx, Apache HTTP Server (mod_proxy), HAProxy
  - 클라우드 서비스의 로드 밸런서(AWS ELB, GCP Load Balancer)
  - CDN (Cloudflare, Akamai 등)도 역방향 프록시의 일종.

### RESTFul API란?
- REST란?
  - REpresentational State Transfer의 약자.
  - 주요 목적은 클라이언트(프론트엔드)와 서버(백엔드)가 데이터를 주고받는 방식을 정리하고 표준화하는 것
- RESTFul 한 것은 어떤 의미일까?
  - REST 원칙을 잘 지킨 API. 
    - HTTP 프로토콜을 기반으로, 리소스(Resource)를 URI로 표현하고, 적절한 HTTP 메서드(GET, POST, PUT, DELETE 등)를 사용하는 API
- 왜 RESTFul API를 만들어야 할까?
  - 클라이언트-서버 분리 → 확장성과 유연성
  - HTTP 프로토콜을 그대로 활용 → 불필요한 복잡성 제거
  - 무상태성(Stateless)이기에 확장성(Scalability) 용이
- 요소:
  - 패스 (리소스): 복수로 표현하며, 웹에서 다루는 모든 데이터(사용자, 글, 상품 등)를 하나의 자원으로 보고, 이를 URI로 표현
    - 왜 복수여야 하는가?
      - 각 패스를 컬렉션으로 표현하여, 해당 컬렉션 하위의 리소스를 특정할 수 있게하기 위함
    - 패스에 id 등으로 리소스를 노출시키는 것은 보안적으로 문제가 없는 것인가?
      - 노출시키는 자체는 문제가 되지 않음 -> 일반적으로 인증/인가에 대한 절차를 갖춘 시스템이라면 문제가 되지 않을 것.
      - 없다면 문제가 됨.
  - Method:
    - GET: 자원 조회
    - POST: 자원 생성
    - PUT/PATCH: 자원 수정
    - DELETE: 자원 삭제
    - HTTP 메서드들 중 포함 안되는 애들도 있는데 이유는 무엇?
      - OPTIONS, HEAD, TRACE 등이 포함되지 않음
      - 자원조작의 목적에 맞지 않는 메서드들이기에 없음.
        - REST에서 핵심은 리소스를 CRUD(Create, Read, Update, Delete) 인데 다른 메서드들은 그러한 기능을 처리해 줄 수 없음
        - OPTIONS는 클라이언트 - 서버간 메타 정보 교환용의 메서 (CORS Preflight 요청에 의해 자동으로 발생)
  - Representation:
    - 자원 자체가 아니라 그 자원의 **표현(JSON, XML, HTML 등)**을 주고받음. 
    - 일반적으로 REST API에서는 JSON을 많이 사용
  - 무상태성(Stateless)
    - 요청 간에 서버가 클라이언트의 상태를 저장하지 않음. 
    - 각 요청은 필요한 모든 정보를 담아야 하며, 독립적으로 처리

### Sync vs Async & blocking vs non-blocking
- 동기 vs 비동기 (synchronous vs asynchronous):
  - 작업 완료에 대한 제어 흐름을 어떻게 처리할 것인가 
- Blocking vs Non-blocking:
  - 호출 스레드가 작업 완료를 기다리며 멈추는가, 계속 실행하는가
- 발생할 수 있는 조합:
  - 동기 + Blocking 
    - 정의: 요청을 보낸 쪽이 결과가 나올 때까지 멈춰서 기다림.
    - 단순하지만, 응답 지연이 길면 전체 프로세스가 멈춤.
  - 동기 + Non-blocking 
    - 정의: 호출은 즉시 돌아오지만, 호출자가 **직접 상태를 계속 확인(polling)**해야 함.
    - 호출자는 멈추지 않지만, 직접 확인해야 해서 비효율적일 수 있음.
    - 예시:
      ```java
        Future<String> f = executor.submit(task);
        while (!f.isDone()) {  // 직접 상태 확인 (busy waiting)
            Thread.sleep(100);
        }
        System.out.println(f.get());
      ```
  - 비동기 + Blocking 
    - 정의: 요청은 비동기적으로 수행되지만, 호출자가 결과를 필요할 때 get() 같은 메서드로 차단해서 기다림.
    - 병렬 실행은 되지만, 결과를 모으는 순간 block 발생
      ```
      Future<String> f = executor.submit(task);
      // ... 다른 작업 수행 ...
      String result = f.get(); // 결과 필요할 때 여기서 block
      ```
  - 비동기 + Non-blocking 
    - 정의: 요청 후 기다리지 않고, 콜백/이벤트/Promise 등을 통해 완료 시 알림을 받음.
    - 가장 효율적 (쓰레드 block 없음, 자원 활용 극대화). 
      - 하지만 설계가 복잡해질 수 있음 (콜백 지옥, async/await 필요).
      ```java
      fetch("http://example.com")
      .then(response => response.json())
      .then(data => console.log(data));
      ```