### 멀티캐스팅, 브로드캐스팅, 유니캐스팅:
- 유니캐스트: 이름에서 알 수 있듯 1대1.
- 브로드캐스트: 같은 네트워크(브로드캐스트 도메인)에 있는 모든 장비에 패킷을 전송
- 멀티캐스트: 1대N 방식으로, 특정 그룹의 수신자들에게만 전송
- 멀티와 브로드캐스팅 차이:
   1. 특정 그룹에 보낸다 (멀티캐스팅)
   2. 같은 네트워크에 속한 모든 유저에게 보내버린다 (브로드)
- 멀티 캐스팅과 브로드캐스팅의 경우, 공용 인터넷에서 제공한다기 보단, 내부망 환경에서만 사용할 수 있는 기능이라 봐야함.
  - 멀티캐스트: IPTV 스트리밍
  - 브로드캐스트: DHCP 룩업 
- WebRTC는 어디에 속하는가?
  - 스펙만 생각하면 당연히 멀티캐스팅일 것 같으나, 유니캐스트이다
  - 왜냐하면 WebRTC는 peer-to-peer 가 기본이고, 각 피어간 1대1의 통신은 유니캐스트이다 
    - SFU를 사용해 중앙 서버에서 중개해도 마찬가지인게, 영상을 전달하는 forwarding unit인거지, 연결을 각 피어와 1대1로 이루어진다.
    - 통신의 레벨에선 유니캐스트인 샘

### RabbitMQ 비동기
- 이벤트가 제대로 도착했는지에 대한 보장을 어떻게 할건지에 대한 보장
  - Durable Queue (default) 로 선언하여 해당 큐에 올라간 내용들이 디스크에 저장되게됨
  - 컨수머가 ACK하기 전까지 절대 삭제/소비되지 않음
    - 너무 과하게 실패하게 되면 Dead letter queue 등을 활용하기도 함
  - 컨수머 장애 발생시 메세지를 자동으로 재전송
- 래빗엠큐와 카프카의 차이
  - 메세지 소비
    - 레빗엠큐: 브로커가 큐에 메세지를 푸시하기를 기다리고 컨수머는 큐에 푸시되면 수신
      - 어떤 컨수머가 메세지를 수신하여 브로커에 ACK를 보내면 큐에서 메세지를 삭제함
    - 카프카: 컨수머가 메세지를 계속해서 확인하고, 메세지를 읽을 때 마다 오프셋 트래커를 업데이트함
      - 컨수머가 메세지를 수신했더라도, retention 기간 정책에 따라 로그 파일이 남아있다면 메세지가 삭제되지않음
  - 우선순위:
    - 레빗엠큐에는 우선순위를 조절할 수 있는 priority queue 가 있으나 카프카는 무조건 동등하게 취급함
  - 퍼포먼스:
    - sequential disk I/O를 사용하는 카프카가 구조적으로 훨씬 더 빠름
- 어떤 상황에 RabbitMQ? Kafka?
  - Kafka
    - 이벤트 스트리밍
      - 처리량이 더 높기 때문에
    - 실시간 데이터 처리
      - 지연 시간이 더 짧고, 데이터 분석에 더 적합함
  - RabbitMQ
    - 라우팅이 복잡할 필요가 있는 경우
      - 익스체인지나 바인딩을 다르게 하여 케이스에 맞는 리스너 구현 가능
    - 효과적인 메세지 배달
      - 메세지 생성자가 메세지의 소비 여부를 알 수 있기 때문에, 구체적인 순서가 보장되어야 하는 경우 등에 적합함.
- 참조: [AWS 블로그](https://aws.amazon.com/compare/the-difference-between-rabbitmq-and-kafka/?nc1=h_ls)

