# Ch. Data Models and Query Languages

### What is expected to be learned from this chapter?
- 데이터 모델의 중요성
  - 중요성: 소프트웨어가 문제를 해결하는 방식과 우리가 **문제에 대해 생각하는 방식**에 지대한 영향을 미침
- 관계형 모델 vs 문서 모델의 장단점
  - 두 모델의 장단점, 스키마 유연성, 데이터 지역성(locality) 등의 차이 이해
- Data 에 대한 질의 언어들의 종류와 차이 
- 그래프 데이터 모델
  - 다대다 관계가 복잡할 때 유용한 속성 그래프와 트리플 저장소 모델, 그리고 이를 위한 질의 언어들(Cypher, SPARQL, Datalog).

### Questions to be answered as I read the book
- 데이터 모델이 왜 그렇게 중요한지?
- NoSQL (Not Only SQL)은 왜 탄생했고, 무엇을 해결했을까?
- 객체-관계 불일치(Impedance Mismatch)란?
- 서버 개발시 관계형과 문서형 데이터 베이스 선택의 기준은 무엇인가?
- 그래프 DB는 언제 쓰는가? 

---
### Relational Model Versus Document Model 
- 관계형 모델 (Relational Model): 1970년대 등장. 비즈니스 데이터 처리의 표준. 정규화된 테이블 구조와 조인(Join)을 통해 중복을 줄이고 일관성을 유지함.
- NoSQL: 단순히 SQL이 아닌 것(Not Only SQL)을 의미하며, 확장성과 유연성을 무기로 등장. 
  - 현재는 두 모델이 공존하는 다언어 지속성(Polyglot Persistence) 시대.
- 문서 모델의 강점:
  - JSON 모델: 객체 구조를 그대로 저장하여 임피던스 불일치를 줄임.
  - 지역성(Locality): 
    - 성능상 이점이 있음(예: 이력서 조회)
      - 한 번의 쿼리로 필요한 모든 정보를 가져올 수 있음 
        - 관련된 데이터를 하나의 문서에 모아져있기에 가능
  - 스키마 유연성: 구조가 자주 바뀌거나 정형화되지 않은 데이터를 다룰 때 유리함. 
- 문서 모델의 약점:
  - 조인(Join) 지원 미비: 다대다(Many-to-Many) 관계 처리가 약함. 애플리케이션단에서 조인을 흉내 내야 하므로 코드가 복잡해질 수 있음.
  - 갱신 비용: 문서의 일부분만 수정해도 전체 문서를 다시 써야 하는 경우가 많아, 문서 크기가 크면 비효율적일 수 있음.
- 두 모델이 점점 더 비슷한 방향으로 발전하고 있음 -> 굿 사인!
  
### Query Languages for Data
- 선언형(Declarative) vs 명령형(Imperative):
  - 명령형 (ex: 프로그래밍 언어들, IMS): 
    - _"어떻게(How)"_ **할지**를 지시. 
      - 특정 순서(메서드의 실행순서)로 연산을 수행. 
    - 병렬 처리나 최적화가 상대적으로 어려움.
  - 선언형 (예: SQL, CSS):
    - _"무엇(What)"_ 을 **원하는지**를 정의.
      - 구체적인 수행 방법은 DB 엔진의 옵티마이저에게 일임.
        - 결과의 패턴을 지정하기에
    - 성능 최적화와 병렬 실행에 상대적으로 유리함.
    - **데이터베이스에서는 SQL같은 선언형 질의 언어가 명령형 질의 API보다 훨씬 좋디고 나타났다**
- 스키마-온-리드(Schema-on-read) vs 스키마-온-라이트(Schema-on-write)
  - '스키마-온-리드' 방식(동적 타입과 유사, 문서형에서 사용)
    - 문서/그래프 모델은 읽을 때 데이터 구조를 해석
    - 변경에 유연함.
  - '스키마-온-라이트'(정적 타입과 유사, 관계형에서 사용)
    - 쓸 때 (write) 스키마를 강제하는 해 저장하게 함
    - 데이터의 일관성이 보장됨.
- MapReduce:
  - 선언형과 명령형의 중간.
  - map과 reduce 함수를 이용해 대규모 데이터를 분산 처리.
    - map을 통해 질의된 값을 키와 밸류로 분리
    - reduce를 통해 같은 키에 대해 밸류에 대한 연산이 적용된다
  - 제한:
    - map & reduce는 추가적인 데이터 베이스 쿼리를 실행할 수 없고, 반드시 순수한 함수여야함
      - 자바스크립트 코드를 사용 (MapReduce에만 해당되는 것은 아님)
      - 두개의 연계된 함수의 퀄리티가 굉장히 좋아야함
    - 별도의 사이드 이펙트가 존재해서는 안됨
  - MongoDB 등에서 지원하나, 작성이 복잡하여 몽고도 2.2 버전부터 선언형 쿼리 언어(declarative aggregation pipeline)를 추가하는 추세.
  - 저자는 이걸 왜 맨션한 걸까?
    - MapReduce는 분산환경에서 유연한 데이터 처리를 가능하게 해주는 프로그래밍 모델이다
    - 선언형 처럼 query optimizer 를 통한 최적화 기회도 없는데 이 mapReduce가 강력한 상황은 언제가 되는걸까?

### Graph-Like Data Models
- 사용 목적: 
  - 다대다 관계가 매우 일반적이고 복잡할 때(소셜 그래프, 웹 링크 등) 사용. 
- 장점:
  - 그래프는 발전성이 좋아서 애플리케이션에 기능을 추가하는 경우 애플리케이션의 데이터 구조 변경을 수용하게끔 그래프를 쉽게 확장이 가능함
- 속성 그래프 (Property Graphs):
  - 정점(Vertex)과 간선(Edge)으로 구성되며, 각각 속성(키-값)을 가질 수 있음.
    - vertices 의 요소:
      - 고유 식별자
      - outgoing edge 집합
      - incoming edge 집합
      - 속성 컬렉션 (키-밸류 페어)
    - edge 의 요소:
      - 고유 식별자
      - tail vertex
      - head vertex
      - head vertex 와 tail vertex의 관계를 설명하는 레이블
      - 속성 컬렉션 (키-밸류 페어)
  - data's granularity (데이터의 입도)?
    - 데이터간의 입도
      - 2-5 예제에서 루시의 출생지는 아이다호로 state level로 명시되어 있으나 다른 정보들을 city 레벨까지 저장되어 있다.
  - Cypher: 
    - Neo4j에서 사용하는 선언형 질의 언어. 
    - 그래프 순회(Traversal)를 직관적으로 표현.
    - optimizer 가 존재해 효율적인 전략을 자동으로 선택해줌
  - ex: Neo4j, Titan, InfiniteGraph 등
- SQL의 그래프 쿼리:
  - 그래프 쿼리에서는ㄴ 찾고자 하는 정점을 찾기 전에 가변적인 여러 간선을 순회해야 하기에 조인수를 고정할 수 없다
    - 그러나 관계형 데이터 베이스에서는 쿼리에 필요한 조인을 미리 알고 있어야한다
    - 이 문제를 해결하기 위해 SQL:1999부터는 recursive common table expression이 추가 되었다 (PostgresQL, Oracle, IBM DB2, SQL 서버에서 지원)
      - 그러나 문법이 매우 어렵고 길다.
  - **다양한 데이터 모델이 각기 다른 사용 사례를 만족하기 위해 설계되었음을 알려준다.**
    - 어플리케이션에 적합한 테이터 모델 선택이 중요한 이유이다.
- 트리플 저장소 (Triple-Stores):
  - three-part segments (subject, predicate, object) 로 데이터를 저장.
    - three-part segments: 
    - 주어: 속성의 vertex 와 동일
    - 2가지 케이스에 따라 다른 세그먼트가 달라짐:
      - 목적어가 문자열이나 숫자 등 원시 테이터타입:
        - 서술어 & 목적어: property graph의 vertex 속성 컬렉션 (키, 값)과 동등
          - ex:(루시, 나이, 33) -> {"age":33} 속성을 가진 lucy 와 동일
      - 목적어가 그래프의 다른 정점:
        - 서술어: 속성 그래프에서 그래프의 edge
        - 주어: 속성 그래프에서 tail vertex
        - 목적어: 속성 그래프에서 head vertex
  - 시맨틱 웹(Semantic Web)
    - 트리플 저장소와 관련 깊음다고 알려져 있으나, 독립적인 개념이라 봐야한다
    - web of Data -> 만물 데이터 베이스 (database of everything)
    - 2000년대 초 과대평가되었고, 현실에서 실현된 흔적이 없어 부정적인 견해가 많다.
  - ex:Datomic, Allegrograph 등
  - SPARQL: 트리플 스토어를 사용하는 RDF 데이터 모델을 위한 쿼리
- 데이터로그 (Datalog):
  - 스파클, 싸이퍼 보다 오래된 언어. 이후 질의 언어들의 기반이 됨. 
  - 규칙(Rule)을 정의하여 데이터를 추론하는 방식.
  - 트리플 스토어 모델과 비슷한 데이터 모델을 사용함
    - predicate(subject, object)

### Summary
- 역사적으로 계층 모델(트리) -> 관계형 모델(테이블) -> NoSQL(문서, 그래프) -> 다언어 지속성(Polyglot Persistence, 관계형 + 문서형) 시대
- 각 모델별 선택할시 고려할 근거들:
  - 문서 모델은 데이터가 독립적인 문서 형태이고 관계가 드물 때 유리함. 
  - 그래프 모델은 데이터 간의 연결과 관계가 복잡할 때. 
  - 관계형 모델은 데이터가 정형화되어 있고 조인이 중요할 때 강점. 
- 만능 모델은 없음. 
  - **애플리케이션의 요구사항에 맞춰 적절한 모델을 선택하거나 혼합해서 사용해야 함.**
- 그래프와 문서형 모델의 공통점:
  - 스키마를 강제하지 않음
    - 요구사항의 변경이 많은 경우 애플리케이션을 쉽게 변경할 수 있음
- 게놈 등 아직 이 세가지의 모델외 다른 모델로 처리하는 경우도 존재한다.

----
### Questions Resolved After Reading the book
- 데이터 모델이 왜 그렇게 중요한지?
    - 대부분의 어플리케이션은 데이터 모델의 레이어링으로 만들어짐
        - Key question is: 각 상위 계층(Layer)로 갈 때 마다 이 전 계층의 복잡성을 숨기고 깔끔한 데이터 모델을 넘기는 행위가 대부분의 어플리케이션의 작업.
            - 각 계층의 데이터 모델:
                - API 레벨에선 객체/자료 구조의 형태로 받고
                - JSON, XML, 관계형 디비의 테이블, 그래프 모델 등으로 저장
                - 메모리/디스크/네트워크 어딘가에 저장된 데이터는 bytes로 표현되고, 탐색, 수정 처리등이 가능
                - 전류, 빛의 파동 등으로 바이트를 표현하는 레이어 (아주 로우 레벨에서)
    - **다양한 데이터 모델이 각기 다른 사용 사례를 만족하기 위해 설계되었음**
      - 설계 목적에 맞는 데이터 모델을 선택해야 어플리케이션 개발시 효용을 볼 수 있음
- NoSQL (Not Only SQL) 의 탄생
    - 무엇이 필요했나?
        - 대규모 데이터셋에 대한 높은 쓰기 처리량(확장성)
        - 무료 오픈소스에 대한 선호 (여기도 오라클이..?)
        - 관계형 디비에는 없는 특수 쿼리 (MapReduce 등) 동작 지원
        - 동적 스키마(스키마 유연성)에 대한 니즈.
    - 그 모든걸 해결했나?
      - 문서 찹조 (다대일, 다대다 관계를 표현하기위해 사용되는 키 값) 등을 활용해 아직까지는 CODASYL의 뒤를 밟고 있지는 않은 것 같다.
      - 그러나 완벽한 대세가 되지는 못했음.
        - 저자의 의견으론 가까운 미래에 관계형과 문서형을 동시에 사용하는 polyglot persistence, 관계형 + 문서형 시대가 올 것 같다고 함
- 객체-관계 불일치(Impedance Mismatch)란?
    - 애플리케이션 코드와 데이터베이스 모델 사이의 전환 계층에서 발생하는 번거로움. 
    - ORM이 이를 완화하지만 완벽하지 않음.
- 서버 개발시 관계형과 문서형 데이터 베이스 선택의 기준
    - 내결함성과 동시성 처리
      - 내결함성으로 인한 선택은 챕터5에서 다시 마주할 것
      - 동시성 처리로 인한 차이점은 챕터7에서 다시 마주할 것
    - 데이터가 독립적 문서 형태이며 관계가 없는 경우: 문서형!
      - 어플리케이션에서 테이터가 문서와 비슷한 구조일 경우
        - 일대다 관계 트리
        - 한번에 전체 트리 적제
        - 레코드간 관계가 없는 경우
      - 스키마 유연성과 지역성에 기반한 더 나은 성능이 있음
    - 데이터가 정형화 되어 있고, 관계에 따른 Join이 중요할 떄: 관계형!
      - 연관관계가 적당(너무 과하지 않고) 조인을 통한 서치가 많이 발생하는 어플리케이션
- 그래프 DB는 언제 쓰는가?
    - 데이터 간의 연결(Relationship)이 데이터 자체보다 더 중요하고 복잡할 때(예: 소셜 네트워크, 추천 시스템) 
    - 어떤 레코드든 모든 레코드들과 연결될 가능성이 있는 경우