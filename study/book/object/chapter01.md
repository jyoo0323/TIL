# 0장 프로그래밍 패러다임

- 모든 언어는 각각의 지향하는 프로그래밍 패러다임이 있고 이를 따라 설계된다. 그렇기에 해당 언어에 능통해지기 위해선 반드시 그 패러다임을 잘 알아야한다.

> 각 프로그래밍 언어가 제공하는 특징과 프로그래밍 스타일은 해당 언어가 채택하는 프로그래밍 패러다임에 따라 달라진다. 
> - C 언어는 절차형 패러다임 을 기반으로 하는 언어이며 
>- 자바(Java)는 객체지향 패러다임을 기반으로 하는 언어다. 
>- 함수형 패러다임을 수용한 가장 대표적인 언어는 리스프(LISP)이며 
>- 프롤로그(PROLOG)는 논리형 패러다임을 수용한 대표적인 언어다. 
>- 각 패러다임과 패러다임을 채용하는 언어는 특정한 종류의 문제를 해결하는 데 필요한 일련의 개념들을 지원한다.
- 각 언어들의 어떠한 특징이 이러한 차이를 만드는 것일까?
  - 절차형 패러다임 (C)
    - 절차(Procedure) / 함수 호출 기반 제어 흐름
    - 메모리 제어(포인터, 주소 연산)를 직접적으로 제공 -> 시스템 프로그래밍에 강함
    - 어떻게 해결할지를 단계적으로 나열하여 해결방안에 도달하는 방식
  - 함수형 패러다임 (LISP)
    - 함수(Function)를 일급 시민(First-class citizen)으로 취급
    - 무엇을 계산할지를 수학적 함수 조합으로 표현
  - 논리형 패러다임
    - 사실(Fact)과 규칙(Rule)로 지식 표현 → 논리 추론
    - 규칙 기반 추론을 통해 답을 도출
      - 개발자가 해결 방법(How)을 직접 정의하지 않고, 조건(What)만 제시

----
# 1장 객체, 설계

- 로버트 L 글래스의 주장에 따르면 이론의 정립보단, 실무에서의 활용이 먼저 앞서고 이후 그 시행착오를 통해 이론이 성장을 이룬다고 함
  - 소프트위어 분야는 아직 역사가 짧은 걸음마 단계의 학문이기에, 실무가 무조건 더 앞서있을 거라는 의견이라 함
  - 대표적으로 소프트웨어 설계와 유지보수는 이미 아주 오랜 기간 이어져온 행위이나, 이론으로 적립되기 시작한 것은 70년대라고 함
  - 이 의견이 공감이 많이 가는 부분이, 내 경우에도 많은 이론을 공부해 왔던 것 같으나 (겉할기일지라도..) 제대로된 설계이론과 특히 유지보수에 관한 논문이나 책은 많이 보지 못했다.
- 첫번째 나왔던 예제 코드가 변경 용이성과, 쉽게 이해할 수 없는 코드라는 이유:
  - 가장 큰 문제는 Audience, TicketSeller가 변경되는 경우에 Theater가 영향을 받게 된다는 점이다.
    - **의존성**이 너무 강하게 결합되어 있기 때문에 발생하는 문제로 (aka 높은 **결합도**) , Audience 가 Bag 을 가지고 있을 것이라 가정하는 점이나, 판매원이 반드시 어떤 매표소에 종속되어야 하는 점 등, 종속적인 관계에서 발생하는 변경에 용이하지 않다는 점이 문제이다.
  - 그 다음의 문제는 관람객과 판매원이 소극장의 통제를 받는 수동적인 존재라는 점
    - Theater 라는 클래스에서 관람객의 Bag 에 있는 초대장을 확인하고, 판매원(TicketSeller) 의 인스턴스 변수인 TicketOffice 로 부터 
    - 현실에 대입해 생각해봤을 때, 소극장이 고객의 가방을 털어 초대권이나 돈을 찾아간다는 문제도 있지만, **프로그래밍 관점으로 생각하면 역할의 분담이 전혀 되어있지 않다는 문제가 있는 듯 하다**
----
### 설계 개선하기
- 변경의 자유로움과 개발자의 이해도는 엮여있는 문제이다.
- 예시에 대한 해결은, **Theater가 Audience와 TicketSeller에 관해 너무 세세한 부분까지 알지 못하도록 정보를 차단하면 된다.** => **관람객과 판매원을 자율적인 존재로 만들면 되는 것** 
  - 어떻게 자율적으로 만들 수 있는가?
    - 개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것을 캡슐화(encapsulation)
    - 캡슐화의 목적은 변경하기 쉬운 객체를 만드는 것. 
    - 캡슐화를 통해 객체 내부로의 접근을 제한하면 객체와 객체 사이의 결합도를 낮출 수 있기 때문에 설계를 좀 더 쉽게 변경할 수 있게 된다.
    - 핵심은 **객체 자기 자신의 문제를 스스로 해결할 수 있도록 만드는 것**
      - 관람객이 티켓을 구매하는 방법 (현금, 카드, 초대장) 을 전부 Audience에 일임했고, TicketSeller 역시 판매하고 매표소에 관람객이 지불한 금액을 추가해 주기만 한다.
      - 밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체를 가리켜 응집도(cohesion)가 높다고 표현함. 
      - 자신의 데이터를 스스로 처리하는 자율적인 객체를 만들면 결합도를 낮출 수 있고 (loose coupling) 응집도를 높일 수 있다 (high cohesion).
    - 이 예시에서는 Theater 행하던 모든 연산행위를 TicketSeller의 sellTo(Audience) 로 일임하고, TicketSeller.sellTo 메서드에서는 티켓을 구매하기 위해 관람객이 구매하는 모든 연산행위를 Audience의 buy(Ticket) 으로 일임하여 각각의 객체가 스스로의 문제를 해결하여 (자신의 일만 자신이 담당하고, 다른 작업을 각각의 다른 객체를 호출하여 처리) 문제를 해결함.
---
### 절차지향과 객체지향
- 기존 Theater 의 코드처럼, 프로세스와 데이터를 별도의 모듈에 위치시키는 방식을 절차적 프로그래밍이라함.
  - 절차지향적 코드는 전형적인 의존성 구조를 보여줌.
  - 그렇다면 절차지향적 프로그래밍은 무조건 나쁜 것일까? C는 아직도 널리 쓰이는 프로그래밍 언어인데 C는 대표적인 절차지향적 언어라고 저자가 이야기 했다. 
    - 절차지향은 작은 규모의 문제 해결에는 단순하고 효율적임
      - 대규모 시스템에서는 저자가 말한 유지보수성과 확장성에서 문제가 발생하는 듯 하다
    - C가 널리 사용되는 이유: 사용되는 영역이 다름
      - OS, embedded system, network driver, DB engine, etc.. 
        - -> 성능과 하드웨어 자원에 대한 제어를 위해 하드웨어의 가까운 저수준의 언어를 요구함
      - 해결해야하는 문제의 성격이 절차지향이 적합한 영역이고 (하드웨어의 자원 제어는 절차적으로 이루어져야 안전) 

### 책임의 이동
- *책임*은 객체지향 세계에서는 기능을 의미한다
- 객체지향 프로그래밍에선 이 책임을 각 객체가 적절히 분배되어 있는 구조가 좋은 구조이고 객체 스스로 자신을 책임지게 해야한다.

### 트레이드 오프
- 저자는 **더 개선할 수 있다** 서브 챕터에서, 책임의 이동을 통한 구조 변경을 하던 도중, TicketOffice로 sellTicketTo(Audience) 를 만드는 것은 TicketOffice 에 불필요하게 Audience 라는 의존성이 생기게 되기 때문에 좋은 설계가 아니라고 이야기 했다. 
  - 일반적으로는 책임을 분산해 자율권을 찾아주는게 더 좋은 설계로 이어지나(Audience와 Bag을 나눈 경우가 그러하다), TicketOffice의 자율성 보다, Audience와의 결합도를 낮추는 것이 더 좋은 설계가 될 수도 있다는 것이다.
  - 또 이러한 트레이드 오프는 어떠한 기능을 설계하는 방법은 한가지 이상일 가능성이 높으며, 동일한 기능은 여러가지 방법으로 설계가 가능하니 어떤 것을 잃는게 더 크리티컬할지를 염두에 두고 개발을 하는 것이 좋다.

### 객체지향 설계
- 저자가 가장 좋아하는 설계의 정의 => _설계란 코드를 배치하는 것이다._
- 설계와 구현은 떨어트려서 이야기할 수 없고, 모든 순간 코드를 어떻게, 어디에 배치할 것인지를 결정하는 과정에서 나오는 것.
>좋은 설계란?
>  - 오늘 요구하는 기능을 온전히 수행
>  - 내일의 변경을 매끄럽게 수용할 수 있는 설계
- 즉 진정으로 우리가 원하는 것은 _변경에 유연하게 대응가능한 코드_
- 객체지향적 코드는 일반적으로는 코드 변경이라는 측면에 한해 다른 방법들보다 안정감을 준다.